## 全局变量

前面聊到了静态持续变量的链接性，其中链接性为外部的变量通常简称为外部变量。它们的存储持续性为静态，作用域为整个程序。外部变量是在函数外部定义的，因此对于所有的函数而言都是外部的。因此外部变量也被称为全局变量。

关于外部变量，C++当中有一个单定义规则：变量只能有一次定义。

这句话看起来有些难以理解，为了理解它，我们需要厘清 C++当中的两种变量声明。一种是定义声明简称为定义，它给变量分配存储空间。另外一种是引用声明，简称为声明，它不给变量分配存储空间。因为它表示引用一个已有的变量。

引用声明使用关键字`extern`，并且不进行初始化。否则会被视为是定义，而非声明。

```C++
double up;
extern int blue;
extern char ch = 'z';
```

上面的例子当中，第一行和第三行为定义声明，因为第一行没有加关键字`extern`，而第三行的变量进行了初始化。

可能到这里还是有些难以理解，其实`extern`是为了引入其他文件创建的变量。如果我们不加`extern`，表示在当前文件当中创建一个全局变量，而加上了`extern`表示引入其他文件创建的全局变量。外部链接性的全局变量虽然是整个程序都可使用的，但跨文件使用时，需要手动使用`extern`声明。

没有通过`extern`声明的其他文件的全局变量也是无法使用的。

当我们同时使用局部变量和全局变量的时候会发生什么呢？比如下面这段代码：

```C++
// file1
double warning = 3.0;

// file2

extern double warning;

void test() {
    double warning = 5.0;
    cout << warning << endl;
}
```

在这段代码当中， 我们在`file1`中创建了变量`warning`，在`file2`当中声明了这个全局变量。并且在`test`函数当中又定义了一个新的`double`类型的变量也叫做`warning`，那么问题来了，当我们使用`cout`输出的时候，究竟得到的结果会是什么呢？

答案很简单，得到的结果是 5.0。因为当同时使用同名的局部变量和全局变量时，局部变量将隐藏全局变量。

那么全局变量和局部变量究竟应该使用哪一种呢？

很明显，全局变量非常方便，使用全局变量可以免去很多参数传递的过程，大大简化了编码的难度。但如果是在大型的工程当中，使用全局变量则是一个非常危险的行为。因为全局变量人人都能访问，我们很难保证数据的准确性，会不会遭遇不可知的更改，排查的时候也更加困难。而使用局部变量，参数传递的链路是清晰的，debug 的时候会容易许多。

在我们日常的算法联系当中，并不存在数据不可靠的问题。使用全局变量可以简化许多数据结构的实现过程，尤其是一些相对复杂的数据结构。我认识的所有算法竞赛的大牛，都非常喜欢使用全局变量。所以到底该用哪个并不是固定的，要根据我们的实际需要进行选择。
