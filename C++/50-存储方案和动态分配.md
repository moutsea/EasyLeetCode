## 存储方案和动态分配

在之前的文章当中，我们讨论了 C++用来为变量分配内存的 5 种方案，但是这些方案并不适用于使用`new`运算符分配的内存，这种内存被称为动态内存。

我们在之前的文章当中也曾介绍过，动态内存由`new`和`delete`控制，而不是由作用域和链接性规则控制。所以我们可以在一个函数当中分配动态内存，在另外一个函数中释放。

通常 C++编译器当中有三块独立的内存，一块用于静态变量，一块用于自动变量，还有一块用于动态存储。

虽然存储方案的概念不适用于动态内存，但是适用于动态内存的自动和静态指针。C++ Primer 当中有这么一个例子，我们在一个函数当中有如下语句：

```C++
float * p_fees = new float[20];
```

很明显，我们通过`new`创建了一个长度为 20 的 float 数组，这块数组的内存将会一直停留在内存当中，直到使用`delete`语句释放。但当该函数运行结束的时候，`p_fees`这个指针将会消失。如果希望在其他地方能够使用这个数组，需要将地址通过某种方式返回或者传递。

如果我们将`p_fees`的链接性声明为外部的，那么我们在其他地方都可以访问到了，如果另外的文件当中需要访问，也同样可以使用关键字`extern`。

### 初始化

前面讲了使用`new`申请内存的方法，如果我们想要在分配内存的同时完成变量的初始化，应该怎么办呢？

如果要为内置的标量类型分配空间并初始化，可以在类型名后面加上初始值，并将它用括号括起来：

```C++
int *pi = new int(3);
double *pd = new double(99.9);
```

如果我们要初始化结构体或者是数组，则需要使用大括号的列表初始化，这需要编译器支持 C++11，这是 C++11 中的新特性：

```C++
struct P {
    int x, y;
};

P *p = new P{3, 4};
int *arr = new int[4] {2, 3, 4, 5};
```

在 C++11 当中也支持对单值变量使用列表初始化：

```C++
double *pd = new double(99.99);
```
