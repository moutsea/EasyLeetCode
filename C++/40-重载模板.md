### 重载模板

函数模板可以使得同一个函数对不同类型使用，非常地方便。但有的时候类型不同，只是通过模板是没办法解决的， 可能逻辑上也会有所区别，这个时候只是使用模板是无法解决的。

为了满足这种需求，我们可以像是重载函数那样重载模板。和常规的函数一样，重载的模板的函数特征，也就是入参的数量和类型必须有所不同。

举个例子，比如我们之前定义了一个函数模板用来交换两个变量的值。如果我们要交换的不只是变量，而是两个数组，就必须要修改逻辑了。

```C++
template <typename T>
void Swap(T &a, T &b);

template <typename T>
void Swap(T *a, T *b, int n);
```

可以看到我们额外传入了一个`int` n，它表示数组的长度。另外，我们入参的类型也发生了变化，不再是模板类型`T`的引用，而是指针了。因为我们要接收的是一个数组，而数组在函数传递当中都是以指针的形式进行的。所以这里要写成指针，当然也可以写成这样：`T a[]`，两种形式本质上没有区别。

所以我们实现的话会是这样：

```C++
template <typename T>
void Swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

template <typename T>
void Swap(T *a, T *b, int n) {
    for (int i = 0; i < n; i++) {
        Swap(a[i], b[i]);
    }
}
```

### 问题

到这里，相信大家也能看出一点问题。

假设我们有这样一个模板函数：

```C++
template <typename T>
void Swap(T a, T b);
```

虽然理论上类型`T`是万能类型，什么类型都可以接受。但我们操作的时候会有很多问题，比如我们执行`a = b`，对于数组类型就会报错。

再比如我们执行`a > b`，很多类型也无法进行比较大小。再比如进行算术运算等等，很多类型比如指针、数组或者结构体也没办法进行算术运算。

总之模板的功能是很局限的，有的时候只能处理某些类型，很难通用覆盖所有情况。当然有的时候也是有一些其他办法绕开的，比如结构体也可以重载比较运算符，也可以重载一些算术运算符等等。

除此之外，C++当中也提供了另外的解决方案。由于篇幅的限制，我们下次再说~
