## 内部链接性

当我们使用`static`关键字，将变量的作用于限制在整个文件时，该变量的链接性为内部链接性。在多文件的程序当中，内部链接性和外部链接性是有所差别的，内部链接性的变量只能在当前文件使用，而常规外部变量是可以跨文件使用的。

但这就带来了一个问题，如果我们在两个文件当中都定义了同一个全局变量，会发生什么呢？

```C++
// file1
int error = 20;

// file2
int error = 5;
```

答案是，这样的做法会报错，因为它违反了单定义规则。

但是我们可以将其中一个变量通过`static`关键字变成静态内部变量，那么在该文件当中，静态变量将隐藏常规的外部变量：

```C++
// file1
int error = 20;

// file2
static int error = 5;
```

这样做的好处是，当我们确定我们某些变量的使用范围只有当前文件的时候，我们可以使用`static`关键字来防止它和一些其他文件当中的外部变量相冲突。

## 无链接性

无链接性的变量我们在之前的文章当中也曾经提到过，其实就是在代码块当中使用`static`关键字创建的。

在代码块当中创建的静态变量会和代码块的生命周期脱钩，虽然它只能在代码块运行时使用，但它的结果会一直存在，并不会随着代码块的执行结束而消亡。

```C++
void test() {
	static int ret = 0;
	ret++;
	cout << ret << endl;
}

int main() {
    test();
	test();
	return 0;
}
```

这段代码的运行之后将会得到 1 和 2，因为`ret`是一个无链接性的静态变量，它会一直存在。所以当`test`运行一次之后，它的结果会变成 1，并被保存下来。

主要应用场景就是我们希望有些变量能够随着代码块的运行有所沉淀，记录下中途的状态或者是中间结果。有了静态变量就可以不必使用全局变量了。
