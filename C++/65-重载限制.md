## 重载限制

上一篇我们讲了在类和结构体当中重载运算符，关于运算符的重载并不是随心所欲的。C++给出了一些限制，从而保证了规范，以及程序运行的准确性。

下面我们就来一一来看下：

### 必须至少有一个操作数是用户定义的类型

这句话看不明白没有关系，我们只需要记住它的目的就好了。它的主要目的是为了防止用户为了标准类型重载运算符。比如将+重载成两个数的差，而不是和。

这种限制对创造性有一定的影响，没有那么灵活，但可以保证程序的正常运行。不会出现一些反人类的情况

### 不能违反运算符原来的规则

这一点很好理解，比如+号，它的运算就是计算两个数的和。需要有两个操作数，现在我们把它重载成一个操作数，就是违法的。

```C++
P p;
+p;
```

同样，我们也不能修改运算符的优先级，如果将加号运算符重载成两个类相加，那么新的运算符和原来的加号拥有一样的优先级。

### 不能创建新运算符

这一点之前已经说过了，比如不能定义`operator @`等这种原来没有的运算符。

### 禁止名单

有一些运算符是禁止重载的，如：`sizeof, ., ::, ?:, typeid, const_cast, dynamic_cast, reinterpret_cast, static_cast`

这些运算符往往都有特殊的功能，直接从实现层面禁止重载。

### 部分运算符只能通过成员函数重载

大多数运算符都可以通过成员函数以及非成员函数进行重载，但也有部分例外，只能通过成员函数重载，如：

- =：赋值运算符
- (): 函数调用运算符
- []: 下标运算符
- ->: 箭头符号

这里的非成员函数看起来有些费解，之后我们会遇到，主要是指友元函数。
