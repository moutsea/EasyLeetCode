## 右值引用

### 左值和右值

在我们之前的文章当中，介绍的都是左值引用。C++11 在左值引用的基础上推出了右值引用，由于是新特性，加上使用的频率也不是很高，有一定的学习成本。

我们先把引用这个概念抛开，先来看看什么是左值什么是右值。其实很简单，左值可以取地址，位于等于号的左侧。而右值没办法取地址，位于等于号的右侧。

```C++
int a = 4;
```

比如我们定义了一个`int`型的变量 a，让它的值等于 4。其中 a 位于等于号的左侧，并且我们可以求 a 的地址。而 4 位于等于号的右侧，我们没有办法对 4 取地址。所以 a 是左值，4 是右值。

再比如：

```C++
int test() {
    return 4;
}

int a = test();
```

同样，a 位于等于号的左侧，有办法取地址是个左值。而`test()`是一个临时值没办法取地址，是个右值。

所以到这里就比较清楚了，有地址的变量就是左值，没有地址的常量值、临时变量就是右值。

### 左值引用和右值引用

明白了左值、右值的概念再来看看左值引用、右值引用就简单了。左值引用顾名思义就是能够指向左值不能指向右值的引用。

```C++
int a = 4;
int &b = a;		// 合法
int &c = 4;		// 非法
```

但是左值引用也有例外，就是使用`const`修饰的左值引用是可以指向右值的：

```C++
const int &b = 4;
```

因为`const`修饰的引用无法再更改，所以可以指向右值。如果大家度过 STL 代码的话，会发现其中一些函数的入参是`const &`目的就是为了能够兼容传参是常量的情况。比如`vector`当中的`push_back`：

```C++
void push_back (const value_type& val);
```

右值引用和左值引用的概念类似，也就是能够指向右值但不能指向左值的引用。为了和左值引用区别， 使用`&&`也就是两个`&`符。老实讲这个符号很令人费解，因为它和`and`的含义相同。

```C++
int a = 4;
int &&b = 4;	// 合法
int &&c = a;	// 非法
```

上面第三行代码非法的原因是 c 是一个右值引用，它不能指向左值。如果我们非要指向呢？也不是没有办法，可以使用`std::move`函数，它可以将一个左值转换成右值。

```C++
using namespace std;
int a = 4;
int &&c = move(a);
```

`move`函数听起来似乎是移动的意思，但其实它并没有移动变量，只不过做了一个类似于类型转换的操作。

不知道大家看到这里有没有觉得头大，其实还没有结束，还有一点很重要。即左值引用和右值引用这两者本身都是左值引用：

```C++
void test(int && tmp) {
    tmp = 2333;
}

using namespace std;

int a = 4;
int &b = a;
int &&c = 4;

test(a);	// 非法
test(b);	// 非法
test(c);	// 非法
test(move(a));// 合法
test(move(b));// 合法
test(move(c));// 合法
```

C++中的引用是一个非常大的范畴，除了左值引用、右值引用之外还有非常多的细节。比如万能引用、引用折叠、完美转发等……
