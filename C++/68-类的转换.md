## 类的转换

在 C++当中，我们经常用到类型转换。其中有一些类型是能够自行转换的。

比如：

```C++
long count = 8;
double time = 11;
int side = 3.33;
```

其中 8 是`int`类型，被转换成了`long`类型，11 是`int`类型，被转换成了`double`类型。这样的转换之所以能够发生，是因为它们之间能够兼容。

有一些转换不太兼容，可能就没办法直接执行，比如：

```C++
int *p = 100;
```

100 是一个`int`型，而等号的左边是一个`int *`是一个指针类型，两者并不兼容。虽然计算机当中的地址也是用整数来表示的，但从概念上来说，这两者不是一个东西。

这个时候如果我们要强行进行转换，就需要使用强制转换：

```C++
int *p = (int *) 10;
```

虽然编译器并不会报错，但是显然，这样的转换并没有实际意义。在我们自定义的类当中，我们同样可以实现这样的转换。

我们来看这段代码：

```C++
class Time {
 	private:
    	int minutes;
    public:
    	Time();
    	Time(int m) {
			minutes = m;
		}
};
```

我们简化了之前例子中的`Time`类，让它只包含一个`int`。我们当然可以使用构造函数来创建对象：

```C++
Time a = Time(10);
Time b(10);
```

但这个构造函数还有一个特殊的用法，就是用在类型转换上。由于它只有一个参数`int`，所以我们可以直接将一个`int`类型转换成`Time`类的对象，like this：

```C++
Time c = 10;
```

这里利用了 C++隐式转换的方式，除了隐式转换之外，我们也可以显式转换：

```C++
Time c = (Time) 19;
```

有的时候，我们不希望发生这样的隐式转换怎么办？因为有的时候可能会导致一些意外的转换。因此 C++当中提供了一个新的关键字叫做`explicit`，在构造函数当中加上这个关键字之后将会关闭类的隐式转换：

```C++
class Time {
 	private:
    	int minutes;
    public:
    	Time();
    	explicit Time(int m) {
			minutes = m;
		}
};
```
