## 多态



在我们之前介绍的继承的情况当中，派生类调用基类的方法都是不做任何改动的调用。



但有的时候会有一些特殊的情况，我们会希望同一个方法在不同的派生类当中的行为是不同的。举个简单的例子，比如`speak`方法，在不同的类当中的实现肯定是不同的。如果是`Human`类，就是正常的说话，如果是`Dog`类可能是汪汪，而`Cat`类则是喵喵。



在这种情况下只是简单地使用继承是无法满足我们的要求的，最好能够有一个机制可以让方法有多种形态，不同的对象去调用的逻辑不同。这样的行为称为多态。



这里稍微强调一下，多态是一种面向对象的设计思路，本身和C++不是强绑定的，其他语言当中一样有多态，只不过实现的方式可能有所不同。



在C++当中有两种重要的机制用于实现多态：



- 在派生类当中重新定义基类的方法
- 使用虚方法



我们来看一个例子：



```C++
class Mammal {
	private:
		string name;
	public:
		Mammal(string n): name(n) {}
    	string Name() const{
            return name;
        }
		virtual void speak() const {
			cout << "can't say anything" << endl;
		}
    	virtual ~Mammal() {};
};

class Human : public Mammal{
	private:
		string job;
	public:
		Human(string n, string j): Mammal(n), job(j) {}
		virtual void speak() const {
			cout << "i'm human" << endl;
		}
};
```



由于示例比较简单，所以我们把类的声明和实现写在一起了。



从结构上来看，这就是一个简单的继承，我们实现了两个类，一个叫做`Mammal`，一个叫做`Human`，然后给它们各自定义了一些成员变量。



值得注意的是`speak`函数，我们在函数声明前面加上了一个关键字`virtual`，这表示这是一个虚函数。



方法被定义成虚方法之后，在程序执行的时候，将会根据派生类的类型来选择执行的方法版本。在进行调用的时候，程序是根据对象类型而不是引用和指针的类型来选择执行的方法，如：



```C++
Mammal *m = new Human("man", "spiderman");
m->speak();
```



这里我们用一个`Mammal`的指针指向了一个`Human`类型的对象，当我们调用方法的时候，由于`speak`方法是一个虚方法。因此执行的时候程序会根据对象的类型也就是`Human`去执行`Human`对象中的`speak`方法，而不是`Mammal`中的。



通常我们会将析构函数也设置成虚方法，因为派生类当中往往有一些专属成员，这是一种惯例。因为如果析构函数不是虚函数，那么只会调用对应指针类型的析构函数，这意味着可能在一些情况下产生错误和问题。



在上述的示例当中，我们是将类方法的实现和声明写在一起了，如果还是采取和之前一样分开实现的方式，需要注意我们无需在函数签名中加上`virtual`关键字。



