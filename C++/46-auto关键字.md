### auto 关键字

我们现在知道，使用`auto`关键字可以自动推导变量类型，尤其是在一些很复杂的情况下，使用`auto`可以大大简化代码。但是在早期的 C++和 C 语言当中，`auto`关键字被用来显式地表示某个变量为自动存储。

```C++
auto float dis;
```

这个功能几乎不被使用，所以在 C++11 当中进行了更新，赋予了它新的含义。

### 静态持续变量

除了自动存储变量之后，C++当中还有静态持续变量。关于静态持续变量的定义 C++和 C 语言是一样的，它拥有三种链接性，即**外部链接性、内部连接性和无链接性**。其中外部链接性指的是可以在其他文件中访问，内部链接性指的是只能在当前文件访问，无链接性指的是只能在当前函数或代码块中访问。

这三种链接性虽然范围不同，但都在整个程序运行期间存在，因此它们的寿命更长，由于在程序运行期间，静态持续变量的数目保持不变，因此不需要使用栈来管理它们。编译器将会分配固定的内存块来存储所有的静态变量，这些变量在整个程序运行期间一直存在。

并且所有没有显式初始化的静态变量，编译器都会将它置为 0。在默认情况下，静态数组和结构将所有元素和成员的所有位都置为 0。

下面介绍一下这三种静态持续变量的创建方法：

```C++
int cnt = 1000;
static int one_file = 50;

void func1(int n) {
    static int ret = 0;
}

int main() {
	// some statements
}
```

在上面这段代码当中，我们定义了三个静态持续变量：`cnt`,`one_file`,`ret`。其中`cnt`为外部链接性，它可以在任何地方使用。`one_file`为内部链接性，可以在当前文件中任意地方使用。而`ret`没有链接性，只能在函数`func1`中使用。

但是这里有一点要注意，虽然`ret`只能在函数`func1`中使用，但这并不意味着函数`func1`执行之前`ret`不存在。前面说了静态持续变量拥有单独的内存块来存储，并不受函数生命周期的影响。我们来看一个例子：

```C++
void test() {
	static int ret = 0;
	ret++;
	cout << ret << endl;
}

int main() {
    test();
	test();
	return 0;
}
```

请问当我们运行上述代码，屏幕当中会得到什么结果？

答案是 1 和 2，因为`ret`变量是一个静态持续类型，虽然我们只能在函数`test`内部使用它，但它不受函数`test`生命周期的影响。也就是说`static int ret = 0;`这句初始化语句只会在`test`函数第一次执行时执行一次，之后即使函数退出，这个值依然存在。当我们第二次执行的时候，由于`ret`变量已经存在，所以并不会将它再置为 0。

对于这里用到的关键字`static`，简单理解成静态是不妥的。其实它有两层含义，当我们是在一个函数内部局部声明的时候，它表示的是这个变量是一个无链接性的静态变量，表示的是存储的持续性。当用于代码块外部声明时，`static`表示的是内部链接性，如果不加`static`则表示外部链接性。所以这其中的作用是有一点区别的，也有人将它称为关键字重载，即关键字的具体含义取决于上下文。
