## 重载<<运算符

我们可以对<<运算符进行重载，这样做的好处是我们可以直接使用`cout`来进行输出。有些类似于 Java 当中实现`toString`方法。虽然概念简单，但是实际实现要稍稍复杂一些，我们一点点来说。

还是以之前的`Time`类为例，假设 trip 是`Time`类的一个对象，为了显示它的值，之前是开发了`show`函数。如果重载了<<运算符之后，我们可以这样输出：

```C++
cout << trip;
```

显然<<是可以被重载的运算符，实际上在 C++当中，它已经被重载很多次了。

<<最原本的含义是左移，这是一个位运算，`i << 1`，表示将 i 左移一位。由于 C++当中整数都以二进制存储，所以这表示`i *= 2`。`cout`是一个`ostream`对象，它能够识别所有的 C++基本类型，它对所有的基本类型都重载了`operator<<`。

现在我们要做的就是重载`Time`类中的<<运算符。

### 版本一

我们必须要使用友元函数，因为<<操作符的运算对象并不是`Time`，而是`cout`。大概是这个样子：

```C++
void operator<<(ostream &os, const Time &t) {
    os << t.hours << " hours, " << t.minutes << " minutes.";
}
```

### 版本二

这个版本看起来一切正常，但是有一个缺陷，就是无法执行如下的连续输出：

```C++
cout << "Trip Time: " << trip << endl;
```

当我们使用`cout`进行连续输出`cout << x << y`，它的本质是`(cout << x) << y`。也就是说`cout << x`的返回结果同样是一个 ostream 的对象。既然如此，我们只需要将上面的版本改下即可：

```C++
ostream& operator<<(ostream &os, const Time &t) {
    os << t.hours << " hours, " << t.minutes << " minutes.";
    return os;
}
```

注意这里返回的类型是 ostream 对象的引用，因为函数开始执行的时候，程序传递的就是一个对象的引用，现在又返回回去，也就是说将传递进来的对象又返回了回去。

这样一来才算是真正实现了。
