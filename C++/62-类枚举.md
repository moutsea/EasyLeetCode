## 类常量

有的时候， 我们希望能给类当中定义一些常量，可以给所有类的对象使用。

比如说我们在类当中定义一个数组，希望可以定义一个常量，用来初始化数组的长度。既然是用来初始化数组长度的，那么这个值自然也不会改变，我们定义成`const`是否可行呢？比如这样：

```C++
class P {
    private:
    	const int N=15;
    	int costs[N];
    ...
}
```

很遗憾，这样不行，编译器会抛出一个错误：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gxbx0p5vktj311u07ymxw.jpg)

说我们`non-static`变量 N 用的不对，看到了吧？报错信息里的描述是`non-static`变量，也就是说我们这里定义的 N 不是一个 static 类型的，所以不能用来初始化数组。

那怎么样才算对了呢？很简单，我们可以定义成 static 变量就对了。

```C++
class P {
    private:
    	static const int N=15;
    	int costs[N];
    ...
}
```

也就是在`const int`前面加上了 static 关键字，表示这是一个 static 即静态变量。这个常量会和其他静态变量存储在一起，而不是存储在对象里，这样的话也就被所有对象共享了。

对于像是 Java、Python 等其他语言来说，类中的静态变量是可以通过类名直接访问的，而 C++中不行。

除了定义静态变量之外，还有一种方法就是定义类枚举：

```C++
class P {
    private:
    	enum {N=15};
    	int costs[N];
    ...
}
```

这样也能运行，看起来非常不可思议。

通过这种方式声明并不会创建类数据成员，对于类的对象来说，并不包含枚举，这里的 N 只是一个符号名称。在类当中遇到它的时候，编译器会用 15 来代替。

也正是因为我们只是为了创建符号常量，而不是创建枚举类型的变量，所以不需要提供枚举名。有一些 C++的类库当中也用到了这种方法，比如`ios_base::fixed`等。

## 类枚举

传统的枚举类型变量存在一定的问题，最大的问题是当两个枚举定义中的枚举量重名的时候，就会发生冲突：

```C++
enum A {small, big, medium};
enum B {small, large, xlarge};
```

这两个枚举类型当中都有`small`，如果位于相同的作用于，那么就会发生冲突。

为了避免这个问题，C++11 当中提供了一种新枚举，它的作用域为类，声明类似这样：

```C++
enum class A {small, big, medium};
enum class B {small, large, xlarge};
```

和上面的代码几乎是一样的，只不过多了一个关键字`class`，换成`struct`也是可以的。

当我们使用的时候，需要加上解析运算符：

```C++
A choice = A::small;
B c = B::large;
```

另外我们前面说过，常规的枚举将自动转化为整型，比如赋值给 int 变量或者是用于比较表达式的时候。而作用域内枚举不会隐式地转换类型。
