## 引用与结构体

最后， 来聊聊将引用和结构体。

结构体是我们自定义的复合类型，本质上也是一种变量类型，所以一样可以使用引用。传递结构体引用的方式和其他变量一样：

```C++
struct P {
    int x, y;
};

void set_axis(P& a, P& b);
```

前文当中也曾说过，虽然引用在基本类型上一样适用，但一般在实际使用当中，不在基本变量类型上使用引用。倒不是有什么问题，而是没有必要，毕竟基本变量类型占据的内存太小了，值传递和引用传递带来的差别几乎可以忽略不计。

因此使用得比较多的就是引用传递结构体，因为结构体当中的成员变量往往比较复杂，通过引用传递可以避免结构体的整体拷贝，可以节省时间和内存。

不仅如此，我们还可以通过函数返回引用：

```C++
P& return_ref(P& a);
```

返回引用的目的和传递引用参数的目的是一样的，为了节省时间和内存。

如果函数返回的不是引用，而是结构体的值的话，调用代码可能是这样的：

```C++
P m = return_ref(a);
```

`return_ref`这个函数的返回结果会先赋值到一个临时的位置，然后再复制给`m`。这和我们传递结构体参数的开销是一样的，如果我们返回的类型是引用，那么则可以节省掉这个开销。

但是，这里有一个坑。

我们通过函数返回的引用，不能是函数终止时就不存在的内存单元，也就是不能是临时变量。比如下面这个例子就是不行的：

```C++
P& return_ref(P& a) {
    P cur = a;
    return cur;
}
```

我们在函数当中将传入的结构体`a`拷贝了一份，对这个拷贝体进行了返回。这样的代码从逻辑上看是没有问题的，但问题是我们创建的`cur`是一个临时变量，当函数返回的时候就会被销毁，不再存在，于是就会导致一些未知的错误。

所以如果要使用函数返回引用的话，一定要返回外部传入的引用或者全局变量的引用，而不能在函数内部临时创建。

除此之外，返回引用还有另外一个坑点，我们来看代码：

```C++
P a,b;

return_ref(a) = b;
```

这样的语法是被允许的，因为`return_ref`函数返回的是一个引用，我们当然可以对一个引用的值进行修改。有的情况下这一样会产生问题，如果你不想要这样的情况被允许，也有办法，我们可以使用`const`关键字，将返回的结果限制成不可修改：

```C++
const P& return_ref(P& a);
```
