## 函数模板

所谓函数的模板，本质上也就是使用泛型来定义函数。

所谓的泛型其实也就是不定的类型，比如说我们使用`vector`的时候，可以定义各种类型的`vector`，可以定义存储`int`型的`vector`也可以定义存储`float`类型的，也可以定义存储其他类型。我们在声明的时候将存储的类型当做参数传给了模板。

泛型可以用具体的类型，比如（`int`或`double`）替换，通过将类型作为参数传给模板，编译器会根据传递的参数类型生成该类型的函数。这种方式也被称为通用编程或者参数化类型。

举一个很简单的例子，比如说我们要实现一个函数交换两个变量的值。对于`int`类型我们要实现一遍，对于`double`类型我们又要实现一遍，如果还需要其他类型，那么又需要额外实现很多同样逻辑的函数。当然可以拷贝代码，但显然这样会很浪费时间，而且会使得代码变得臃肿。

这个时候我们就可以使用函数模板自动完成这一功能，函数模板允许以任意类型来定义函数，所以我们就可以这样实现：

```C++
template <typename T>
void swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
```

当我们要创建一个模板的时候，需要首先声明模板的类型，也就是`template`语句做的事情。关键字`typename`也是必须的，也可以使用`class`代替。`typename`关键字是在 C++98 标准添加的，所以在更早的版本中往往使用`class`。在这个场景下，这两种方式是等价的。C++ Primer 当中更建议使用`typename`而非`class`。

`typename`之后跟的是类型的名称，我们可以使用任意的名字，一般来说习惯性地会使用字母`T`。我们在使用的时候和普通函数并没有什么不同，当做普通函数使用即可。

```C++
template <typename T>
void swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int i = 10, j = 20;
swap(i, j);
double a = 3.0, b = 4.0;
swap(a, b);
```

虽然我们只实现了一次函数，但是在编译的时候，编译器会将这个函数根据我们使用的情况生成多个版本。比如在上面的代码当中，我们使用了`int`和`double`两种类型的函数。编译器会替我们生成两份代码，也就是说最终代码上和我们手动实现函数重载是一样的，可以理解成一种方便我们程序编写的特性。
