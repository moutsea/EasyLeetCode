## 引用

引用是 C++新增的特征，C 语言当中没有。

引用是给已经定义的变量一个别名，可以简单理解成同一个变量的昵称。既然是昵称或者是别名，显然它和原本的变量名有着同样的效力。所以我们对别名进行修改，原本的变量值也一样会发生变化。

我们通过符号&来表明引用，比如下面这个例子，我们创建了 a 变量的一个引用 b。

```C++
int a = 3;
int &b = a;
b++;
cout << a << endl;
```

由于 b 是 a 的一个引用，本质上来说它们是同一个变量，只不过名称不同。所以我们对 b 修改，等价于对 a 进行同样的修改。所以输出的结果是 4。

也就是说我们需要把引用变量和原变量当成是同样的变量，只不过名称不同，其中一个发生变化，另外一个一样会生效。

看上去有些像是指针，因为创建指针也能有类似的效果：

```C++
int a = 3;
int *p = &a;

*p++;
cout << a << endl;
```

但是引用和指针还是有些区别，这个问题在 C++相关的面试当中经常会问到，也是作为基本功的考察之一。

首先一个区别是，引用必须在声明的时候就进行初始化，没办法先声明再赋值：

```C++
int *pt; 	// 合法
int &b;		// 非法
```

从这个角度来说，引用更接近`const`指针，一旦与某个变量关联就不能再指向其他变量：

```C++
int &b = a;
// 等价于
int *const pt = &a;
```

在这个例子当中，`b`等价于`*pt`。

如果我们输出引用和原变量的地址，会得到同样的结果：

```C++
int a = 3;
int &b = a;

cout << &a << " " << &b << endl;
```

### 函数引用传递

其实到这里有一个问题，既然引用只是别名，我们已经有了原本的变量名可以用了，又何必多此一举创建变量的引用呢？

所以引用不是为了顺序执行的逻辑创建的，一个最常见的使用场景就是函数参数传递的时候，可以设置函数接收的变量类型为引用。如：

```C++
void swap1(int& a, int& b) {
    int temp = b;
    b = a;
    a = temp;
}

void swap2(int a, int b) {
    int temp = b;
    b = a;
    a = temp;
}
```

我们创建了两个`swap`函数，其中一个传递的参数是引用，另外一个就是普通的值传递。如果大家去分别调用这两个函数进行尝试，会发现`swap2`函数没有生效。

因为值传递的时候，会发生拷贝，也就是说函数内部接受的其实是变量的拷贝。我们对于拷贝无论如何修改也不会影响原值，而传引用就不一样了。前面说过，引用和原变量是等价的。我们对引用进行修改等价于对原变量进行修改。

这样的话，我们就可以实现在函数体内部对外部传入的参数进行修改。在一些特殊的场景当中，非常方便。比如一些复杂的树形数据结构，通过使用引用可以大大降低代码的编写难度。

除此之外，使用引用还有一个好处，既然我们传递的引用和原值是等价的。那么也就免去了拷贝变量的开销，如果我们传递的是`int`，`double`这样的变量还好，如果是一个包含大量元素的容器，如`vector`,`set`,`map`等，使用引用传递可以带来明显的效率提升，也会降低内存开销。
