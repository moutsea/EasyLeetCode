## 函数重载

函数重载还有一个别名叫函数多态，其实我个人感觉函数多态这个名字更好理解更恰当一些。

函数多态是 C++在 C 语言基础上的新特性，它可以让我们使用多个同名函数。当然这些同名函数的参数是要有区别的，我们在函数调用的时候，编译器会自动根据我们传入的参数，从多个同名函数当中找到我们调用的那一个。和面向对象里的多态的概念很接近。

我们在定义函数的时候，编译器只会查看参数的数目和类型，而不会理会参数的名称。只要参数的数量以及类型不完全相同，就会被认为是不同的函数。比如：

```C++
void print(const char *str, int width);
void print(double d, int width);
void print(long l, int width);
void print(int i, int width);
void print(const char *str);
```

上面列举的 5 个函数它们彼此之间的函数参数的数量和类型都不完全相同，因此会被视为是不同的函数。我们在使用的时候编译器会根据我们传入的参数使用对应的函数。

```C++
print('pancakes', 15);	// use 1
print('pancakes');		// use 5
print(1999.0, 10);		// use 2
print(199, 23);			// use 4
print(199L, 15);		// use 3
```

这当然没有问题，如果我们这样使用呢：

```C++
unsigned year = 2021;
print(year, 6);
```

我们可以发现我们这里传入的参数类型是`unsigned int`，它不和任何函数的入参类型匹配。这个时候编译器并不会放弃，而是会尝试使用标准类型转换强制进行匹配。但问题来了，我们有三个版本的函数的第一个入参是数字类型，于是就有了三种变量转换的方式。这个时候 C++将拒绝这种函数调用，进行报错。

同样，一些看起来彼此不同的参数也是不能共存的，比如：

```C++
double cube(double x);
double cube(double &x);
```

看起来一个是值传递一个是引用传递，但是对于编译器来说，显然它是无法分辨我们究竟要调用哪一个的。

还有一点需要注意，就是`const`修饰符。

```C++
void dribble(char *bits);			//1
void dribble(const char *bits);	//2
```

`dribble`函数有两个类型，一个用于`const`指针，一个用于常规指针，编译器将会根据实参是否为`const`来决定使用哪个函数。因为将非`const`值赋给`const`变量是合法的，但反之是非法的。

另外，编译器区分函数是根据函数的参数数量和类型并不是根据函数的返回值。所以下面的两个声明是有问题的：

```C++
long gronk(int n, float m);
double gronk(int n, float m);
```

因为它们的参数数量以及类型都是一样的，尽管返回类型不同，但编译器依然无法区分。

这个问题经常在面试当中出现，面试官会故意挖坑问你，函数重载的依据是什么。如果两个函数的返回类型不同，但是参数一样，能不能重载。很多同学对重载的概念记忆不是非常深刻，面试的时候脑子一热就中招了，所以一定要注意。
