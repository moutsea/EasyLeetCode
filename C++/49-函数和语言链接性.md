## const

关于`const`的含义和使用我们之前已经讨论过了，但`const`限定符对于默认存储类型是有影响的。

在默认情况下，全局变量的链接性是外部的，也就是说所有文件均可使用。但`const`全局变量的链接性是内部的，也就是说只能在本文件当中使用。全局`const`定义就好像使用了`static`说明符一样。

这个设定看起来有些令人费解，其实是编译器中的一个优化。因为我们常常将一组常量放在头文件当中，并且在多个文件当中`include`这个头文件。如果`const`声明的链接性也是外部的，根据单定义规则，这会出错。正是为了避免这种情况发生，所以编译器做了优化，规定了`const`关键字修饰的全局变量，链接性也为内部。

如果出于某种原因，程序员希望某个常量的链接性为外部的，可以使用`extern`关键字来覆盖默认的内部链接性：

```C++
extern const int states = 30;
```

在这种情况下，必须所有使用了该常量的文件中使用`extern`关键字来声明它。然而，由于`const`在多个文件之间共享，因此只有一个文件可以对它进行初始化。

## 函数和链接性

和变量一样，函数也有链接性。和 C 语言一样，C++不允许在一个函数当中定义另外一个函数，因此所有函数的存储持续性都默认是静态的，即在整个程序运行期间都一直存在。

在默认情况下，函数的链接性是外部的，也就是说可以跨文件使用。我们可以使用关键字`static`来讲函数的链接性设置成内部的，这样就只有当前文件可以使用。

我们必须同时在原型和定义当中使用`static`:

```C++
static void test();

static void test() {
    return ;
}
```

单定义规则对于函数也一样适用，也就是说对于非内联性函数来说，程序只能包含一个定义。对于链接性为外部的函数，只有一个文件包含该函数的定义。但使用该函数的每个文件，都应该包含函数的原型。

简单来说，这就是为什么我们通常将函数的原型写在头文件当中，而实现单独放在另外一个 cpp 文件中的原因。因为这样，所有`include`该头文件的文件都包含了函数的原型，但只有对应的`cpp`文件拥有函数的定义。这样就保证了一定不会违反单定义规则。

## 语言链接性

背景知识：链接程序要求每个不同的函数拥有不同的符号名，比如 C 语言编译器可能将`spiff`函数翻译成`_spiff`，这被称为 C 语言链接性。而 C++当中，同一个名称可以对应多个函数（函数重载），因此必须将这些函数翻译成不同的名称。

比如`spiff(int)`可能翻译成`_spiff_i`，`spiff(double, double)`翻译成`_spiff_d_d`。这种方法被称为 C++语言链接。

如果要在 C++程序当中使用 C 库中预编译的函数可能就会名称对不上，所以为了解决这个问题，我们可以用函数原型来指出要使用的约定：

```C++
extern "C" void spiff(int);
extern void spoff(int);
extern "C++" spaff(int);
```

第一个原型使用的 C 语言链接性，后面两个使用的都是 C++语言链接性。只不过第二个是通过默认方式实现的，而第三个是显式指出的。
