## 引用与指针的区别

指针和引用的原理非常的相似，所以很多时候尤其是面试的时候经常会拿来比较。

本文来梳理一下引用和指针的一些异同。

### 相同点

两者都是关于地址的概念。

指针本身是一个变量，它存储的值是一块内存地址，而引用是某一个内存的别名。我们可以使用指针或引用修改对应内存的值。

### 区别

- 引用必须在声明时初始化，而指针可以不用

我们无法声明一个变量引用再给它赋值，只能在声明的同时进行初始化：

```C++
int a = 3;
int &b;		// 非法
int &c = a;	// 合法
```

而指针没有这个限制：

```C++
int *p;	// 合法
```

- 引用只能在声明时初始化一次，之后不能指向其他值，而指针可以

引用一旦声明无法更改，但指针可以。某种程度上来说，引用类似于常量指针。

```C++
int a = 3;
int &b = a;
int const *p = &a;
```

- 引用必须指向有效变量，指针可以为空

这是两者一个使用上巨大的区别，我们拿到一个引用可以放心地使用， 因为它一定不会为空。而指针则不然，有可能为空指针，必须要经过判断才能使用。

- `sizeof`运算结果不同

`sizeof`函数可以计算变量内存块的大小，但如果我们对指针使用`sizeof`得到的是指针这个变量本身的占用内存大小，而不是指针指向的变量的内存大小。而引用则没有这个问题。

- 有指针的引用，但是没有引用的指针

我们先来看引用的指针：

```C++
int a = 3;
int &b = a;
int *p = &b;
```

这段代码并不会报错，但如果我们真的去运行了，会发现`p`就是一个普通的`int`型指针，它指向的是变量`a`。因为`b`是一个引用，它的地址和`a`相同。所以我们定义一个指向`b`的指针，实际上就是定义指向`a`的指针。这也是指向引用的指针不存在的原因。

再来看看指针的引用，指针的引用是存在的，也很好理解，本质上就是指针的一个别名：

```C++
int a = 3;
int *p = &a;
int *&pt = p;
```

`pt`也可以指向别的变量，也可以修改解引用的值，使用上它和`p`没有任何区别。

除了上面说的这些之外，指针和引用还在一些细小的方面有一些差别。例如自增和自减的含义不同，指针的自增和自减代表的是指针的移动，而引用的自增自减则是变量的值发生变化。
