## 枚举

### 简介

C++当中提供了枚举操作，我们可以使用`enum`关键字创建枚举类型。

这种方式创建的为符号常量，可以代替`const`关键字，并且还可以自定义名字，让代码可读性更强。如：

```C++
enum color {red, blue, orange, white, black};
```

在这一句语句当中完成两件事，首先我们创建了一个新的变量类型叫做`color`，这是一个枚举类型。其次我们创建了一些符号常量，例如`red`,`bule`,`orange`这些。在默认状态下，会将这些枚举量赋值为整数，第一个枚举量`red`为 0，第二个`blue`为 1，以此类推。

当然我们也可以显示地给这些枚举量赋值，如：

```C++
enum color {red=3, blue=1, orange, white, black};
```

这样前面给定了数值的`red`和`blue`会按照我们给定的值进行赋值，而之后从`orange`开始，依次赋值成 2，3，4.

### 使用

我们定义了枚举类型之后，可以当做正常类型来进行声明：

```C++
color a;
```

由于`color`是一个枚举类型，所以当我们赋值的时候，只能赋值列举出来的类型，如果附上其他的值可能会出问题。根据编译器的不同出现的结果也不一样，有些编译器会报错，有些则只会给出警告。不管是报错还是警告，我们都不应该这么做：

```C++
color a = red;	// OK
color a = 10;	// 报错或警告
```

由于`enum`底层存储的是整型，所以有一些奇怪的操作是允许的，但是也强烈不建议这么做，也可能会有很大的风险。比如：

```C++
cout << red < blue << endl;	// 比较大小
cout << blue - red << endl;	// 做加减法

int c = red + 3;	// 赋值给int
```

这些操作在语法上都是允许的，但非常不推荐这么干，因为没有意义。枚举型当中每一个类型都有各自的逻辑含义，是不能拿来做计算的。虽然语法上可行，但逻辑上没有意义。

我们也可以使用强制转换将整型转成枚举类型：

```C++
color c = color(3);
```

但同样不推荐，因为有可能数字 3 对应的枚举量并不存在，这也不会报错，但也许会影响程序的正确性。

### 枚举值的取值范围

前文说了，只有声明中的枚举值是有效的，然而由于 C++允许使用强制转换转换成枚举值，所以理论上枚举值取值范围内的值都可以被转换成枚举值，虽然这些值在逻辑上不一定有意义。

对于枚举变量来说，它的范围并不是固定的，而是根据定义情况波动的。C++会根据枚举值声明的情况计算上限和下限，只能允许在范围内的整型值强制转化为枚举值。

```C++
enum flag {black = 1, white = 2, red = 23};
```

C++采取的是最小长度的方式，比如说我们上面定义的枚举值最大的是 23，它会计算出大于 23 的最小 2 的幂，也就是 32。所以这个枚举值的上限就是 31，对于下限也会采用类似的计算，如果定义的最小值大于等于 0，那么它的下限就是 0，否则采取同样的算法，只不过加上负号。

之所以会如此复杂，也是为了尽可能地节省内存空间。毕竟很多 C++程序的运行环境都是单片机或者是芯片，内存并不充裕。
